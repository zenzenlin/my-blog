---
title: 介紹
description: 什麼是 Docker？
date: 2025-05-19
read: '1'
icon: noto:construction
authors:
  - name: Mike Lin
    username: zenzenlin
    avatar: https://www.github.com/zenzenlin.png
    to: https://github.com/zenzenlin
    target: _blank
---

## 引言

在現代軟體開發中，「一次建置，處處運行」的理想正逐漸成為現實。Docker 作為容器技術的代表，正是這股浪潮的核心之一。

## 容器技術與虛擬機

### Docker 與虛擬機器不同

Docker **運行應用程式的環境**被稱作 **容器 (Container)**。它不像虛擬機器 (virtual machine ) 需要 虛擬機器監視器 (hypervisor) 模擬出軟體、韌體或硬體，反而**直接運行在宿主機（host machine）的核心**。以執行應用程式的運行來說，虛擬機器需要模擬出整套作業系統才能運行應用程式，而容器則是直接運行在宿主機上。不僅如此，宿主機也可以是虛擬機器。因此，它比虛擬機器又更為輕量級、執行啟動又更快。

過去，當我們想要**在不同的環境下運行同一份程式碼**，我們需要使用虛擬機技術。然而，虛擬機有一些固有的問題，比如**需要的資源多、啟動慢、難以移動和複製**等。容器技術則為解決這些問題提供了新的方向。

容器是一種**軟體技術**，可以**將應用程式及其全部運行環境（包括文件系統、系統庫等）打包在一起，形成一個獨立、一致的運行單元**。容器之間互相隔離，但共享同一個作業系統，**每個容器都像一個輕量級的虛擬機**。這種技術可以讓開發者在不同的系統和環境中，輕鬆地運行和管理他們的應用程式。

|             | 虛擬機 (VM) | 容器 (Docker) |
| ----------- | ---------- | ------------ |
| 啟動速度     | 較慢        | 非常快        |
| 系統資源占用  | 高         | 低            |
| 是否需完整 OS | 是         | 否            |
| 可攜性       | 較差        | 高            |
| 應用隔離性    | 高         | 中～高         |

## Docker 是

> Build and Ship any Application Anywhere (建置任何應用程式並運行在任何地方)

Docker 是一個開源的**容器化平台**，可以用來**打包、運行和分享應用程式**。Docker 通過容器化技術實現了應用程式的**獨立性**和**可移植性**，這代表只要安裝 Docker，就能在不同的作業系統或平台上，毫無差異地執行相同的應用程式，讓開發者和運維人員可以更加便捷地進行應用程式的開發、部署和運維。

## Docker 的優勢與應用場景

- 環境一致

  Docker 可以將應用程式及其所有依賴項**打包在一個容器中**，確保了從開發到測試到生產的整個生命週期中，環境的一致性。這解決了「在我的機器上運行得好好的」這種常見問題，讓開發和發佈有統一的標準環境，也有利於持續整合（CI, Continuous Integration）與持續交付（CD, Continuous Delivery）流程的建立，讓應用程式從寫好程式碼到部署上線都能自動化完成。
  例如，開發者在 macOS 上開發的 Node.js 應用，使用 Docker 打包後可以直接部署到 Ubuntu 的生產環境中，不會因為 Node.js 版本不同而出錯。

- 輕量級和性能優越

  容器提供輕量級的沙盒環境與傳統的虛擬機相比，Docker 容器不需要運行一整套操作系統，而是直接**使用主機的操作系統**，這使得容器變得非常輕量且啟動速度快

- 應用程式隔離

  容器提供輕量級的沙盒環境，每個**容器都在自己的空間中運行**，並有其自己的網路和文件系統，互不干擾。這提供了額外的安全層，也使得各種應用程式可以在同一台機器上共存

- 可移植

  由於容器包含了所有需要的依賴項，因此它**可以在任何安裝了 Docker 的系統上運行**，無論這個系統是物理機還是虛擬機，是在數據中心還是在雲端

- 易於管理和擴展

  Docker 提供了**豐富的工具和平台**，用於管理容器、服務和集群，使應用程式的部署、擴展和運維變得簡單

## Docker 可以做什麼？

- 容器管理

  使用 Docker CLI 建立、啟動、停止、搬移和刪除容器

- 映像管理

  可以從容器建立映像，並推送至映像倉庫以供分享與部署。這是實現快速應用程式部署和擴展的基礎

- 映像版本控制

  透過 tag 機制追蹤映像變化，可回溯特定版本。開發者可以追蹤映像的改變，並在需要的時候回退至先前的版本

- 系統資源隔離

  使用 Linux 的 cgroups 和 namespaces 技術，將每個容器的 CPU、記憶體、網路等與其他容器隔離

- 資源掛載與整合

  容器可掛載的資源如磁盤、網路和檔案系統，使容器可以像真實的獨立系統一樣運行

這些功能構成了 Docker 作為開發、測試與部署平台的基礎。

## Docker 是如何運作的？

Docker 的架構主要由以下三個部分組成：

- `docker daemon` (dockerd)

  Docker 的核心服務程式，稱為 **dockerd**，是常駐在背景的守護行程（daemon process），負責**處理容器的建立、運行與資源管理**等工作

- REST API

  dockerd 暴露出一組 RESTful API，讓用戶或工具可以程式化地控制、操控 Docker，例如管理 Images、containers、networks 和 volumes 等資源

- Docker CLI (Command-Line Interface)

  相較於 REST API，使用者更常透過命令列來操作 Docker。這個 CLI 是與 Docker Daemon 互動的主要方式。CLI 會呼叫 REST API 與 dockerd 溝通

## 容器的物件

### Container(容器)：映像檔的執行物件

Container 是 Docker 的核心技術，運行於 Docker Engine 之上，且在各種作業系統上皆有對應版本。

**容器是映像檔 (Image) 的實際執行物件**，用 `docker + run` / `start` / `restart` / `stop` / `rm` 指令可以管理容器。當容器建立時，容器執行於隔離的沙箱環境中，可視為擁有獨立的檔案系統。另外，我們還可以為 Container 設定 `network` 和 `volume` 等資源，讓其具備通訊與持久化資料的能力：

- `volume` 是容器**與別人共享的資料區**，我們把資料放在裡面，可以：
  1. 與 `Host` 共同存取
  2. 提供其它 Container 掛載 (mount) 使用，共享同樣的資料區
  3. 獨立於 container，當 Container 移除時，`volume` 裡的資料可以保留下來

- `network` 讓我們可以**與別的容器和主機通訊**，像是：從外部存取容器內的服務，可能是從 `Host`，也可能是來自別的 Container

### Image(映像檔)：容器建立的範本

Image 是容器建立的範本，它**打包著相關程式碼、函式庫、環境配置檔**。簡而言之，就是一群檔案集合。Image **常常是基於別的 Image 建立**的，像是我們可以基於 `nginx:1.18.0` 加入客制的 Nginx 設定組態或加入你自己的檔案再重新建置 (build) 一個新的 Image。

當要建立並執行 Container 時一定要指定「唯一」的一個映像檔，如 `docker run <Image>`

### Volume：獨立於容器的檔案空間

在實際應用中，我們常需要容器擁有「持久化資料」或「跨容器共用資料」的能力，以下是常見使用場景：

1. 資料在容器刪除後仍需保留（例如：資料庫）
2. 容器與宿主機 (`Host`) 共享資料夾或檔案
3. 多個容器共用設定檔或資料集

簡單來說當我們需要「資料共用」或「資料保留」，此時就會用到 Volume

`docker run -v (–volume)` 來掛載 volume，格式是：`-v <source>:<target>`：其中 source 可以是宿主機路徑（bind mount）或 volume 名稱，兩者都不會因為容器移除而被自動刪除。；目標 (target) 是指定要掛入容器內的位置。

Docker 提供三種掛載類型(mount types)：

1. `bind mount`：掛入現有的 Host 檔案系統 (filesystem)，用在容器與 Host 共享資料夾或檔案
2. `volume`：掛入 volume 物件
3. `tmpfs mount`：從 memory 掛載

### Network：與容器通訊

網路是 Docker 物件中重要的一環，它可以讓其它人存取容器中的應用程式，也可以讓各個 Docker daemons (dockerd) 串接起來，使容器在它們之間擴張 (scale) 複製，而容器不會察覺它目前運行在哪台主機。

docker 支援許多模式，但我們只考慮本機常遇到的 `bridge` 和 `Host` 使用情境。

- Bridge mode：分離容器和本機的網路

  這是容器**預設的網路模式**。當我們 `docker run` 時，容器會使用一個預設的 network，名稱為 bridge 的網路物件 (不同的作業系統可能名稱會有差異，mac 叫 **bridge**, linux 叫 **docker0**)。容器接上那個預設的 network 並配給一個 IP。

- Host mode：直接使用本機的網路

  這是**最簡單的模式**，容器會共用主機的網路堆疊與 IP，可視為在主機上執行的「本地行程（local process）」，不再有獨立的網路介面。它監聽什麼 `port` ，那麼 `Host` 的 `port` 就會被使用，所以連 `-p` 都不用設定。此外，有個小細節要注意，一個 `port` 只有一個 process 能監聽，同理，一個 `port` 也只能給一個容器物件監聽。
