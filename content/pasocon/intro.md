---
title: 加密
description: 常見的加密有哪些？
date: 2025-05-22
read: '1'
icon: noto:construction
authors:
  - name: Mike Lin
    username: zenzenlin
    avatar: https://www.github.com/zenzenlin.png
    to: https://github.com/zenzenlin
    target: _blank
---

## 加密

::alert{type="info" icon="lucide:info"}
資訊安全的無形盾牌
::

在數位時代，我們的每一次點擊、每一次交流，只要是透過網路，都離不開「加密」這層無形的保護網。它確保了資訊在傳輸過程中的**機密性、完整性與不可否認性**，是構建信任網路的基石。

### 對稱加密 (Symmetric-key Cryptography)

小明與小華想進行通信，為了不讓別人知道他們兩個的通信內容，他們決定用一個特別的書信箱來傳送對話內容，傳送時他們都會將這個書信箱上鎖，而且只有他們兩人擁有一樣的開箱鑰匙。兩把鑰匙只有他們私自擁有，也就是**密鑰**。這兩人共用同一把密鑰通常也稱它為**共享密鑰 (Shared Secret Key)**。

對稱加密的優點是**加解密速度快、效率高**，適合處理大量數據。然而，它最大的挑戰在於：**如何安全地將這把共享密鑰交到對方手上**？如果小明直接把鑰匙寄給小華，途中很可能被中間人截獲，那加密就形同虛設了。這就是對稱加密面臨的「密鑰分發」困境。為了在不安全的網路環境中安全地協商出共享密鑰，**密鑰交換**應運而生。

### 密鑰交換 (Key Exchange)

兩人當中的其中一人 小明 把一把對稱加密的密鑰放進箱子裡，並且給箱子上了 A 鎖頭，目前這個箱子只有小明的金鑰才能打開，然後發送給小華，小華收到後也給這個箱子上了 B 鎖頭，並且上的 B 鎖頭只有小華的金鑰才能打開，再發送回給小明，小明收到箱子後把自己的 A 鎖頭用自己的金鑰打開，再把剩下被小華鎖住的箱子發送給小華，小華收到後把自己的 B 鎖頭打開，並得到小明一開始放在裡面的另一把密鑰，這樣透過自己才有的密鑰將書信箱上鎖、發送、解鎖、再發送的過程，就成功地把對稱加密的密鑰分享給對方了。

以上「交換箱子」的比喻，其實就是**迪菲-赫爾曼密鑰交換 (Diffie-Hellman Key Exchange, DH)** 的簡化版概念。實際當中，小明與小華並不是直接傳遞加密密鑰，而是雙方透過公開參數與個人私鑰，經過一系列數學運算，在不安全的通道上協商出一個共享密鑰，而這個共享密鑰在傳輸過程中從未被公開過。一旦共享密鑰協商成功，後續的通信就可以使用高效的對稱加密進行了。因此這種方式常見就是，用來加密和協商對稱私鑰，畢竟密鑰的體積比真正要傳送的文檔小得多。

### 中間人攻擊 (Man-in-the-Middle Attack)

但是這樣做，還是有可能有中間人把鎖頭給換了，換成中間人自己的鎖頭，再把裡面的文本內容竄改才傳送給一開始的目標對方，因此根本沒辦法確定跟誰進行通信。這就引出了我們需要**身分驗證**的需求。

### 非對稱加密與數位簽章 (Asymmetric-key Cryptography & Digital Signature)

為了驗證通信對象的身份，我們引入了**非對稱加密**的概念。非對稱加密使用一對相關聯的鑰匙：一把**公鑰 (Public Key)** 和一把**私鑰 (Private Key)**。顧名思義，公鑰是公開的，任何人都可以取得；私鑰則必須嚴格保密，只有擁有者才能使用。

非對稱加密有兩種主要應用場景：

1. **加密數據**：用對方的**公鑰加密**，只有對方的**私鑰才能解密**，用於確保數據的機密性。
2. **數位簽章**：用自己的**私鑰加密**（這裡更精確地說，是用私鑰對數據的哈希值進行加密），然後讓對方用自己的**公鑰解密**。這**不是為了保密**，而是為了驗證數據的來源 (身份驗證) 和完整性 (防篡改)。

#### 數位簽章的運作方式：

1. 小明寫了一封信 (明文)，先用哈希函數算出內容的摘要（哈希值，哈希運算是一種單向的數學函數，能夠將任意長度的輸入數據轉換成固定長度的輸出，而且如果文本內容有變動，哈希值也會跟著改變）
2. 他用自己的私鑰對這個哈希值加密，這就變成了數位簽章
3. 小明把這封信和數位簽章一起寄給小華
4. 小華收到信後，也用相同的哈希演算法產生摘要，然後再用小明的公鑰解密數位簽章中的哈希值
5. 如果兩個哈希值一致，小華就能確信：
   - 信確實是小明發的（因為只有小明有那把私鑰）
   - 信的內容在傳輸過程中沒有被動過手腳

即便有中間人攔截了這段訊息，他完全看得懂信的內容 (因為是明文發送)，但是**無法偽造簽章**，因為他沒有小明的私鑰。數位簽章就成功解決了中間人攻擊中的兩個關鍵問題：「**無法確定通信對象**」和「**數據是否被竄改**」的問題。

::alert{title="數位簽章的重點" type="note" icon="lucide:pencil"}
🧾「這封訊息是不是小明本人發的？」→ 私鑰簽名、公鑰驗證
<br/>
🧪「訊息內容有沒有被篡改過？」→ 哈希值驗證完整性
::

### 實務上的加密通訊

結合了前面的加密技術及概念介紹，假設你是小明，要傳訊息給小華，且只有你們兩人能知道內容：

1. 用小華的「公鑰」加密訊息，因為只有小華有對應的私鑰，只有他能解密 → **機密性確保**
2. 用你自己的「私鑰」簽名這段內容 (或其 hash)，這樣對方收到後可以用你的「公鑰」來驗證訊息來源與內容是否被改過 → **不可否認性 + 完整性確保**
3. 小華收到後會做兩件事：
   1. 用自己的私鑰解開加密訊息 → **得到原文**
   2. 用你的公鑰解開簽章，並對照訊息的 hash，看是否一致 → **驗證你是發信人且內容沒被改**

## HTTPS

瀏覽網頁時，網址前方的 HTTPS 就是加密通信的最好證明。`HTTPS = HTTP + TLS`，它是在應用層與傳輸層之間建立的安全層，確保了瀏覽器與網站伺服器之間的通信安全。

### TLS (Transport Layer Security)

TLS 是 HTTPS 的核心，它的前身是 SSL (Secure Sockets Layer)。雖然很多人仍習慣稱 TLS 為 SSL，但如今的 TLS 已經和 SSL 大不相同了，現代瀏覽器早已棄用 SSL，全面採用更安全的 TLS 協定，尤其從 TLS 1.2 進化到 TLS 1.3 後，安全性和效能都得到顯著提升。

TLS 握手過程複雜而精巧，它結合了非對稱加密、對稱加密和哈希運算來達成安全通信：

1. **身分驗證**：伺服器會向客戶端出示數位憑證，其中包含了伺服器的公鑰和憑證頒發機構（CA）的數位簽章。客戶端利用預置在瀏覽器中的 CA 公鑰來驗證憑證的真實性，從而確認伺服器的身分，解決了中間人攻擊的問題。
2. **密鑰交換**：在 TLS 1.2 中，最核心的密鑰交換算法包括 RSA (Rivest-Shamir-Adleman) 和 DH (Diffie-Hellman)。但這些靜態的密鑰交換算法存在一個問題：如果伺服器的私鑰被洩漏，那麼攻擊者可以回溯性地解密過去所有被該私鑰加密的通信內容，這就是**缺乏前向保密性** (Forward Secrecy)。
3. **TLS 1.3 的演進**：為了增強安全性，TLS 1.3 移除了這些存在前向保密性問題的靜態密鑰交換算法，並強制使用具備前向保密性的密鑰交換算法 (如橢圓曲線迪菲-赫爾曼密鑰交換 ECDHE)。這意味著即使某一次會話的私鑰被洩漏，攻擊者也無法解密之前的會話內容，大大提升了安全性。TLS 1.3 還簡化了握手過程，提高了性能。
4. **會話加密**：一旦安全地協商出共享密鑰，後續的實際數據傳輸就會使用高效的對稱加密算法，如 AES (Advanced Encryption Standard)，來進行加密。AES 是一種廣泛應用且安全性高的對稱加密算法，是現代網路通信的主力。

### AES (Advanced Encryption Standard)

:icon{name="noto:construction" size="30"}
