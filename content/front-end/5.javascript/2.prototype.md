---
title: 原型 & 原型鏈
description: 原型 & 原型鏈
date: 2025-05-15
read: '1'
authors:
  - name: Mike Lin
    username: zenzenlin
    avatar: https://www.github.com/zenzenlin.png
    to: https://github.com/zenzenlin
    target: _blank
---

## 前情

OOP（物件導向程式設計）基本概念是一種將現實世界中的事物抽象為**類別（Class）的程式設計方式，每個類別描述了某類事物的屬性與行為，而物件（Object）**則是根據類別建立出的實體，具備具體的資料與功能。

藉由類別代表其最重要的概念或特質或資料或功能，接著根據這個「類別」建立物件實體 (Object instance) — 即該物件包含了類別中所定義的屬性與行為。
而物件的建立過程通常是透過執行類別的建構子（constructor）函式完成的，並自動帶入類別中定義的屬性與方法。

雖然在 ES6 中 JavaScript 引入了 `class` 語法，但本質上它仍是使用「**原型（prototype）**」來實作物件導向。這與傳統的基於類別（class-based）語言不同，JavaScript 採用的是「**基於原型的繼承**（prototype-based inheritance）」。換句話說，JavaScript 的**每個物件都可以指向另一個物件作為原型**，並從中繼承屬性與方法。

## 原型是什麼？

我們可以把原型想像成一個**藍圖**。例如我們想建一台車，就會想到**一台車會包括以下的特性**：

- 車的**種類** (電動車、貨車、摩托車...)
- 車的**顏色** (紅色、黑色、藍色...)
- 車的**坐位數目**

這就是一台車的藍圖，但它只是一個藍圖，並不是實實在在的一台車。接下來我們要實際建出一台車，就可以按這份藍圖去建起來。

- 我的車子跟你的車子**無關係**，是兩個不同的物件，各自按自己的喜好調整屬性值
- 我的車子和你的車子**繼承**了同一個藍圖，它們的內部結構都指向同一個原型對象，因此可以共享藍圖中的方法

```js
function Car(type, color, seats) {
  this.type = type;
  this.color = color;
  this.seats = seats;
}

Car.prototype.drive = function () {
  console.log("Vroom!");
};

const myCar = new Car("電動車", "黑色", 5);
myCar.drive(); // 繼承自 Car.prototype
```

在這個例子中，`Car.prototype` 就是那份「藍圖」，而 `myCar` 是根據它產生的實體車。

## 原型鍊 (prototype chain)

在 JavaScript 中，物件之間的繼承是透過「原型」（Prototype）來實現的，這種繼承機制稱為**原型繼承（Prototypal Inheritance）**。

每個物件在建立時，都會隱式地關聯到另一個物件，這個物件就稱為它的「原型」，並可透過 `__proto__` 屬性（或 `[[Prototype]]`）來存取。這樣一層層的關聯就形成了「**原型鍊（Prototype Chain）**」。

![一個物件裡面除了所給予的屬性值外，另外也包含原型 prototype](https://4.bp.blogspot.com/-fatzOLLqlGM/V2dXLiCs5RI/AAAAAAAAmwE/PLkLHJTmOkIiIz0ftJVdsdWmVhzJqgt8wCLcB/s640/1.png)

一個物件裡面除了所給予的屬性值外，另外也包含原型 prototype

```js
const parent = { greeting: 'hello' };
const child = Object.create(parent);

console.log(child.greeting); // 'hello'
```

child 雖然本身沒有 greeting 屬性，但 JavaScript 會沿著原型鍊向上查找，發現在 `child.__proto__`（也就是 parent）中有此屬性，於是就返回了 `'hello'`。

### 查找屬性的流程

當你存取一個物件的屬性時（如 `obj.prop`），JavaScript 引擎會依照以下步驟尋找：

1. 先在 obj 自身的屬性中尋找 `prop`
2. 若找不到，則往 `obj.__proto__` 的物件中尋找
3. 若仍找不到，繼續往上找，直到原型為 `null`（也就是原型鍊的終點）為止
4. 若整條鍊上都沒有該屬性，則回傳 `undefined`

這樣的查找機制稱為「原型鍊」，它讓物件之間能夠共享屬性與方法，避免重複定義，也使得 JavaScript 的繼承更具彈性。

### `prototype` 與 `__proto__` 的差異

- `prototype` 是屬於「函式」的屬性，用來定義該函式作為建構函式（Constructor）時，新物件的原型
- `__proto__` 是**每個物件的內部屬性，指向它的原型**，也就是那條「原型鍊」的上層節點

## 函式建構式 (function constructor)

在 JavaScript 中，除了使用物件字面量（`{}`）建立物件外，我們也可以透過「函式建構式（Function Constructor）」來建立物件實體。這種方式通常搭配 `new` 關鍵字來使用。

### 使用 `new` 關鍵字時發生了什麼？

當你執行 `new MyConstructor()`，JavaScript 在背後會進行以下幾個步驟：

1. 建立一個全新的空物件：`{}`
2. 將這個物件的 `__proto__` 屬性設為 MyConstructor.prototype
3. 執行 MyConstructor 函式，並將 `this` 綁定到這個新建立的物件上
4. 如果建構式中有明確 `return` 一個物件，則回傳該物件；否則回傳上述新建立的物件

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}

const john = new Person('John', 30);
console.log(john.name); // 'John'
console.log(john instanceof Person); // true
```

### 為什麼可以透過參數創建多個不同的物件？

因為每次呼叫建構式時都可以傳入不同參數，並將這些值指定給 `this` 上的屬性，所以能產生具有相同結構但不同資料的物件。

```js
const alice = new Person('Alice', 28);
const bob = new Person('Bob', 35);

console.log(alice.name); // 'Alice'
console.log(bob.name);   // 'Bob'
```

這種方式就像是用一個模板快速「工廠化」地建立出多個類似的物件。

### return 的例外情況

在函式建構式中，通常不需要寫 `return`。不過：

- 如果明確 `return` 一個物件，這個物件會取代原本預設要回傳的 `this`
- 如果 `return` 是基本型別（如數字、字串、布林值等），會被忽略，仍回傳新物件

```js
function Weird() {
  this.name = 'Default';
  return { name: 'Override' }; // 回傳這個物件，而非預設的 this
}

const obj = new Weird();
console.log(obj.name); // 'Override'
```


當使用 `new` 這個關鍵字時，實際上會先有一個空的物件被建立，接著 `new` 關鍵字函式會被執行，當函式執行的時候，在 execution context 中會有 `this` 被建立，而**當我們使用 `new` 的時候，函式裡面的 `this` 會被指定成剛剛所建立的那個空物件**。只要這個函式建構式沒有指定 return 為其他物件，它就會直接回傳給我們這個新建立的物件，若有 return 其他內容，原本被建立的新物件不會被回傳，而是回傳我們最後 return 給它的內容。

想要建立出同屬性名稱但不同屬性值的物件內容，我們可以**把物件的屬性值變成參數**，如此就能**透過此 function constructor 建立出許多不同的物件。**

## `new`

有了原型鍊的概念之後，就不難理解 `new` 這個關鍵字背後會做的事情是什麼。

假設現在有一行程式碼是：`var nick = new Person('nick');`，那它有以下幾件事情要做：

1. 創出一個新的 object，我們叫它 O
2. 把 O 的 `__proto__` 指向 Person 的 prototype，才能繼承原型鍊
3. 拿 O 當作 context，呼叫 Person 這個建構函式
4. 回傳 O

用「函式建構子」來代表那個藍圖，再用 `new` 的運算子來執行函式建構式，會先建立一個空物件，同時將**該建構式中 prototype 這個屬性的內容 (car.prototype)，設置到該物件實例的 prototype 中 (myCar.**proto**)**。再產生出一個實體物件 (myCar、yourCar)

```jsx
// 建立函式建構子
function car(type, color, person){
  this.type = type;
  this.color = color;
  this.person = person;
}

// 之後用函式建構子來產生實體物件
var myCar = new car('電動車', '紅色', 4)
var yourCar = new car('貨車', '藍色', 2)
```

**函式建構子**裏面有一些屬性：

- 函式裏有 `prototype` 屬性，是一個空物件
- 這個 `prototype` 屬性裏面，再有 2 個屬性：
    1. `constructor` 屬性 (指回這一層它自己的建構函式，`A.prototype.constructor === A`)
    2. `__proto__` 屬性 (再找上一層的原型 (prototype) `object`)

`constructor` 屬性，就是**指回自己這個函式建構子的本身**，即是 `car` 這個函式。`__proto__` 屬性就是**這個函式再上一層的原型**，就是 `object`，因為 `function` 是屬於 `object` 型別。

**實體物件**的特別之處：

- 物件裏有 `__proto__`，裏面有：
    1. `constructor` 屬性 (指向上一層它的建構函式)
    2. `__proto__` 屬性 (再找上一層的原型 (prototype) ) `__proto__`裏面還要包多一個`__proto__`，這裏的 `__proto__` 是指向它的原型，就是`原型`的 `prototype`。

        所以 `實體.__proto__ === 原型.prototype`

    3. 它們都有同一個 `constructor` 屬性，因為它們都是由同一個函式建構子產生的。

**實體物件只有`__proto__`屬性**，不同於**建構函式同時擁有`__proto__`和`prototype`這兩個屬性**。實體物件的`__proto__`，會指向上一層的原型，即上一層的`prototype`，這個上一層的`prototype`會放著：

- `constructor` (指回這一層它自己的建構函式)
- `__proto__` (再找上一層的原型 (prototype) )
- 一些之前定義好的方法 (如有)

![https://i.imgur.com/brNPVuV.png](https://i.imgur.com/brNPVuV.png)
